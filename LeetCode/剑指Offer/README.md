# 一些题解的笔记记录

### 【栈与队列】剑指 Offer 09. 用两个栈实现队列
该题要求使用两个栈实现队列的尾部插入和头部pop，不偷鸡的方法比较简单。

主要思想是push的时候就全往一个栈push。

需要pop的时候如果另外一个栈是空的，就先把现有的栈倒进去。这时候直接取另外一个栈的栈顶就是那个需要的元素，如果另一个栈还为空，则返回-1。

之前Java经验不多，这里首次接触到Java中的栈，要用这种方式来定义（在类实例化的时候实例化的那种感觉），已经不推荐使用Stack，用这个有一种模拟的感觉

```java
class CQueue {
    Deque<Integer> stack;
    
    // 无参构造方法，推荐使用Deque + LinkedList作为栈的实现
    public CQueue() {
        stack = new LinkedList<>();
    }
}
```

### 【栈与队列】剑指 Offer 30. 包含min函数的栈
题目的要求难点主要在要求在O(1)的时间复杂度条件下，求解一个栈中的min元素。

如果使用单个int minValue记录的方法，由于现有栈的最小值存在被pop出去的可能，所以不行。

所以采用维护两个栈的方法，其中主栈就是正常的栈，副栈用来存主栈非严格单调递减的序列（存在相等的可能性），这里有个打字不太好描述那种感觉，就是这个副栈的"实际长度"和主栈实际是同步的，所以只要主栈每次pop的时候，判断和副栈栈顶是不是一样，如果一样就一起pop出去就行了（由于副栈非严格，所以同步）

在这种方法下，副栈的栈顶永远就是当前的min了。

